// 0408.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
	int a = 3;
	/// 포인터 변수 : 선언 *을 붙인다. - 자료형 *변수명;
	///		Ex) int *p;
	/// 포인터 연산자 : 오로지 2개 뿐!
	///		1) * : 변수 선언, 값 접근할때
	///		2) & : 바로 뒤의 변수의 주소를 가져와라!
	/// ==> int 자료형을 가리키는 포인터 p 변수를 선언한다.
	/// ==> a변수의 주소를 가져와서 p 변수에 할당해라~

	int* p = &a;
	/// int p Vs. int* p : 일반 변수 Vs. 포인터 변수 선언
	/// 일반 변수 : 값을 받을 수 있다.
	/// 포인터 변수 : 주소를 받을 수 있다.
/*
	p = 3;		/// p는 주소를 받아야 하는데 3은 상수인 값!
	int k = &a;	/// k는 값을 받아야 하는데, &는 주소를 받환!
	*a = 3;		/// 일반 변수는 앞에 *연산자를 붙일 수 없다.
*/
	/// *p == a = 1
	*p = 1;
	
	printf("a: %d - p: %d\n", a, *p);

	/// 메모릐의 0번지부터는 시스템과 운영체제에 관련된 정보가 기록
	/// 포인터로 해당 위치를 접근하려고 하면 오류가 발생(OS가 강제 종료)
	/// OS나 시스템 메모리 영역에 접근 가능한 OS : real-mode
	/// 접근 요청 시 OS가 접근 불가 OS : protected-mode
/*
	int* k = NULL;
	*k = 3;
	printf("K: %d\n", *k);
*/
	/// 포인터 변수의 초기화
	/// 포인터 변수는 주소만! 받을 수 있기 때문에 반드시!
	/// 초기화할때 변수의 주소로 초기화해야 한다!!!
	/// 일반 변수의 0과 같이 초기화하는 값이 존재 : NULL(0) - C언어
	/// C++에서는 위와 같은 문제점이 있기 때문에 NULL 대신 nullptr을 사용
	//int* p1, p2, *p3;		/// 초기값 없이 연속 선언은 최신 컴파일러에서 거부
	int* c_ptr = NULL;		/// 0; - C언어 스타일
	int* cpp_ptr = nullptr;	/// nullptr - C++ 스타일
	
	/// !!! 포인터는 모든 자료형에 대해서 항상 같은 크기를 갖는다.
	/// 대상 타입 = 실제 타입 : 두 자료형은 무조건 같아야 한다!
	/// char 포인터 = int 변수의 주소
	/// 왜 다르면 안되는가?
	/// cptr은 자료형이 char이기 때문에 주소에 접근할때 1byte씩 접근
	/// int 자료형은 a는 4byte!
	/// 포인터의 자료형에 맞게 메모리에 접근하기 때문에
	/// 서로 다른 자료형을 사용하면 프로그램이 오동작할 수 있다.
	//char* cptr = &a;

	/// 포인터의 연산 : +, - 연산자만 가능!
	/// 아래 나온 연산만 허용. 피연산자의 숫자는 다른 형식으로 변환
	/// 포인터의 연산은 주소 위치를 가리키는 변위 값 연산
	int* pp = &a;
	pp--;
	pp++;
	pp = pp + 1;		/// pp = pp + 1( ==> sizeof(int) * 1)
	pp = pp - 3;		/// pp = pp - 3( ==> sizeof(int) * 3)

	/// 배열 첨자와 포인터
	int array[5] = { 3, 4, 5, 6, 7 };
	/// array[N] == *(array + N)
	array[0] = 9;				/// 배열 문법
	*(array + 1) = 100;			/// 포인터 문법
	for (int i = 0; i < 5; i++)
	{
		printf("array[ %d ] = %d\n", i, array[i]);
	}

	/// void는 자료형으로 선언 자체가 불가능!!!
	//void v = 3;
	/// void*는 자료형으로 선언이 가능!!!
	/// 단순하게 주소를 보관만!!! 해주는 역할을 수행 == 범용 포인터
	void* vp = nullptr;
	vp = &a;
	vp = array;
	char* cpp = nullptr;
	vp = cpp;
	/// void 포인터는 연산이 불가능하다!
	/// 주소 보관 이외에는 어떠한 형태로도 사용이 불가능하다!!!
	//vp++;

	/// int a, int* p는 위에 선언
	//printf("a 변수 : %d %d %d\n", a, *a, &a);
	printf("a 변수 : %d %p\n", a, &a);
	printf("p 변수 : %p %d %p\n", p, *p, &p);
}
